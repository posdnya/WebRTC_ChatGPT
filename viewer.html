<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Viewer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header><b>WebRTC Viewer</b> <span class="small">— watch the shared window</span></header>
  <main>
    <div class="card">
      <div class="row">
        <label class="small">WS URL
          <input id="wsUrl" type="text" value="wss://ws.elecard-signal.com" />
        </label>
        <label class="small">Room
          <input id="room" type="text" value="posdnya" style="width:120px" />
        </label>
        <button id="btnConnect">Connect</button>
        <button id="btnDisconnect" disabled>Disconnect</button>
        <span id="wsStatus" class="small badge">WS: Disconnected</span>
      </div>
      <details class="small" style="margin-top:8px;"><summary>TURN (optional)</summary>
        <div class="row">
          <label>turn URL <input id="turnUrl" type="text" placeholder="turn:host:3478 or turns:host:5349"></label>
          <label>user <input id="turnUser" type="text" placeholder="username"></label>
          <label>pass <input id="turnPass" type="text" placeholder="credential"></label>
          <span class="small">Leave empty to prefer DIRECT path.</span>
        </div>
      </details>
    </div>

    <div class="card">
      <div class="player-wrap">
        <video id="remoteVideo" playsinline autoplay muted></video>
        <div id="clockOverlay" class="clock-overlay" title="Local time">--:--:--</div>
      </div>
      <div class="sep"></div>
      <div class="row small">
        <span id="sigState"></span>
        <span id="iceState"></span>
        <span id="connState"></span>
      </div>
      <pre id="log" class="small"></pre>
      <div class="iframe-wrap">
        <iframe id="clockZoneFrame" title="Clock from clock.zone"
                src="https://clock.zone/" loading="lazy" referrerpolicy="no-referrer"></iframe>
      </div>
    </div>
  </main>

<script>
'use strict';
const wsUrlEl = document.getElementById('wsUrl');
const roomEl = document.getElementById('room');
const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const wsStatus = document.getElementById('wsStatus');
let ws = null;
let room = roomEl.value.trim();

function setWSStatus() {
  const ok = ws && ws.readyState === WebSocket.OPEN;
  wsStatus.textContent = 'WS: ' + (ok ? 'Connected' : 'Disconnected');
  btnConnect.disabled = ok;
  btnDisconnect.disabled = !ok;
}
roomEl.addEventListener('input', ()=> room = roomEl.value.trim());

btnConnect.addEventListener('click', () => {
  room = roomEl.value.trim();
  const url = wsUrlEl.value.trim();
  if (!url || !room) { alert('Fill WS URL and Room'); return; }
  if (ws) try { ws.close(); } catch {}
  ws = new WebSocket(url);
  ws.addEventListener('open', () => { setWSStatus(); try{ ws.send(JSON.stringify({type:'join', room})); }catch(e){} });
  ws.addEventListener('close', setWSStatus);
  ws.addEventListener('error', setWSStatus);
  ws.addEventListener('message', ev => { try { handleSignal(JSON.parse(ev.data)); } catch {} });
  setWSStatus();
});

btnDisconnect.addEventListener('click', ()=>{ try { ws.close(); } catch {}; setWSStatus(); });

function toPlainCandidate(c){ return { candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex, usernameFragment: c.usernameFragment }; }
function sendSig(obj){
  if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({...obj, room}));
}

let pc = null;
const remoteVideo = document.getElementById('remoteVideo');
const sigState = document.getElementById('sigState');
const iceState = document.getElementById('iceState');
const connState = document.getElementById('connState');
const log = document.getElementById('log');
function logln(s){ log.textContent += s + "\n"; }

function getIceServers(){
  const servers = [{urls:'stun:stun.l.google.com:19302'}];
  const turn = document.getElementById('turnUrl')?.value.trim();
  const u = document.getElementById('turnUser')?.value;
  const p = document.getElementById('turnPass')?.value;
  if (turn) servers.push({ urls: turn, username: u || undefined, credential: p || undefined });
  return servers;
}
function ensurePC(){
  if (pc) return pc;
  pc = new RTCPeerConnection({ iceServers: getIceServers() });
  pc.addEventListener('signalingstatechange', ()=> sigState.textContent = 'signaling: ' + pc.signalingState);
  pc.addEventListener('iceconnectionstatechange', ()=> iceState.textContent = 'ice: ' + pc.iceConnectionState);
  pc.addEventListener('connectionstatechange', ()=> connState.textContent = 'conn: ' + pc.connectionState);
  pc.addEventListener('track', e => { if (e.streams && e.streams[0]) remoteVideo.srcObject = e.streams[0]; });
  pc.addEventListener('icecandidate', e => {
    if (e.candidate) sendSig({kind:'candidate', from:'viewer', candidate: toPlainCandidate(e.candidate)});
    else sendSig({kind:'end-of-candidates', from:'viewer'});
  });
  pc.addEventListener('icegatheringstatechange', ()=> { if (pc.iceGatheringState==='complete') logln('gathering complete'); });
  return pc;
}

async function handleSignal(msg){
  if (!msg || msg.room !== room) return;
  if (msg.kind === 'offer' && msg.sdp) {
    try {
      const pc2 = ensurePC();
      await pc2.setRemoteDescription(msg.sdp);
      const answer = await pc2.createAnswer();
      await pc2.setLocalDescription(answer);
      sendSig({ kind:'answer', sdp: pc2.localDescription });
      logln('answer sent');
    } catch(e){ logln('error: ' + (e.message||e)); }
    return;
  }
  if (msg.kind === 'end-of-candidates'){ try{ ensurePC().addIceCandidate(null); }catch(e){} return; }
  if (msg.kind === 'candidate' && msg.from === 'sender' && msg.candidate){
    try { await ensurePC().addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch(e){ logln('addIceCandidate error: '+(e.message||e)); }
    return;
  }
}

// Local overlay clock
(function(){
  const el = document.getElementById('clockOverlay');
  function fmt(n){ return (n<10?'0':'')+n; }
  function tick(){
    const d = new Date();
    const s = `${fmt(d.getHours())}:${fmt(d.getMinutes())}:${fmt(d.getSeconds())}`;
    if (el) el.textContent = s;
    requestAnimationFrame(tick);
  }
  tick();
})();

// Show path hint
async function updatePath(){
  try {
    const pc2 = ensurePC();
    const stats = await pc2.getStats();
    let pair, local, remote;
    stats.forEach(r=>{ if (r.type==='candidate-pair' && r.selected) pair=r; if (r.type==='transport' && r.selectedCandidatePairId) pair = stats.get(r.selectedCandidatePairId) || pair; });
    if (pair){ local = stats.get(pair.localCandidateId); remote = stats.get(pair.remoteCandidateId); }
    if (local && remote) connState.textContent = 'conn: ' + pc2.connectionState + ' — path ' + local.candidateType + '→' + remote.candidateType;
  } catch {}
}
setInterval(updatePath, 2000);

// Iframe hint
(function(){
  const iframe = document.getElementById('clockZoneFrame');
  if (!iframe) return;
  iframe.addEventListener('load', ()=>{ iframe.title = 'Embedded from clock.zone; if blank, site may block embedding. Overlay clock above always works.'; });
})();
</script>
</body>
</html>
