<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Viewer</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .kv{display:inline-flex;gap:6px;align-items:center}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  </style>
</head>
<body>
  <header><b>WebRTC Viewer</b> <span class="small">— watch the shared window</span></header>
  <main>
    <div class="card">
      <div class="row">
        <label class="small">WS URL
          <input id="wsUrl" type="text" value="wss://ws.elecard-signal.com" />
        </label>
        <label class="small">Room
          <input id="room" type="text" value="posdnya" style="width:120px" />
        </label>
        <label class="small">PIN
          <input id="pin" type="text" value="1234" style="width:100px" />
        </label>
        <button id="btnConnect">Connect</button>
        <button id="btnDisconnect" disabled>Disconnect</button>
        <span id="wsStatus" class="small badge">WS: Disconnected</span>
        <span class="badge" id="rttBadge">RTT: —</span>
        <span class="badge" id="brBadge">Bitrate: —</span>
      </div>
      <details class="small" style="margin-top:8px;"><summary>TURN (optional)</summary>
        <div class="row">
          <label>turn URL <input id="turnUrl" type="text" placeholder="turn:host:3478 or turns:host:5349"></label>
          <label>user <input id="turnUser" type="text" placeholder="username"></label>
          <label>pass <input id="turnPass" type="text" placeholder="credential"></label>
          <span class="small">Leave empty to prefer DIRECT path.</span>
        </div>
      </details>
    </div>

    <div class="card">
      <div class="player-wrap">
        <video id="remoteVideo" playsinline autoplay muted></video>
        <div id="clockOverlay" class="clock-overlay" title="Local time">--:--:--</div>
      </div>
      <div class="sep"></div>
      <div class="row small">
        <span id="sigState"></span>
        <span id="iceState"></span>
        <span id="connState"></span>
      </div>
      <pre id="log" class="small"></pre>
      <div class="iframe-wrap">
        <iframe id="clockZoneFrame" title="Clock from clock.zone"
                src="https://clock.zone/" loading="lazy" referrerpolicy="no-referrer"></iframe>
      </div>
    </div>
  </main>

<script>
'use strict';
// URL params → defaults
const urlParams = new URLSearchParams(location.search);
const wsUrlEl = document.getElementById('wsUrl');
const roomEl = document.getElementById('room');
const pinEl  = document.getElementById('pin');
wsUrlEl.value = urlParams.get('ws')   || wsUrlEl.value;
roomEl.value  = urlParams.get('room') || roomEl.value;
pinEl.value   = urlParams.get('pin')  || pinEl.value;

const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const wsStatus = document.getElementById('wsStatus');
const rttBadge = document.getElementById('rttBadge');
const brBadge  = document.getElementById('brBadge');
let ws = null;
let room = roomEl.value.trim();
let pin  = pinEl.value.trim();

function setWSStatus() {
  const ok = ws && ws.readyState === WebSocket.OPEN;
  wsStatus.textContent = 'WS: ' + (ok ? 'Connected' : 'Disconnected');
  btnConnect.disabled = ok;
  btnDisconnect.disabled = !ok;
}
roomEl.addEventListener('input', ()=> room = roomEl.value.trim());
pinEl.addEventListener('input',  ()=> pin  = pinEl.value.trim());

function connectWS(){
  room = roomEl.value.trim();
  pin  = pinEl.value.trim();
  const url = wsUrlEl.value.trim();
  if (!url || !room) { alert('Fill WS URL and Room'); return; }
  if (ws) try { ws.close(); } catch {}
  ws = new WebSocket(url);
  ws.addEventListener('open', () => {
    setWSStatus();
    try{
      ws.send(JSON.stringify({type:'join', room, pin}));
      // просим оффер (на случай если sender уже в комнате)
      ws.send(JSON.stringify({type:'need-offer', room, pin}));
    }catch(e){}
  });
  ws.addEventListener('close', setWSStatus);
  ws.addEventListener('error', setWSStatus);
  ws.addEventListener('message', ev => { try { handleSignal(JSON.parse(ev.data)); } catch {} });
  setWSStatus();
}
btnConnect.addEventListener('click', connectWS);
btnDisconnect.addEventListener('click', ()=>{ try { ws.close(); } catch {}; setWSStatus(); });

function toPlainCandidate(c){ return { candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex, usernameFragment: c.usernameFragment }; }
function sendSig(obj){
  if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({...obj, room, pin}));
}

let pc = null;
const remoteVideo = document.getElementById('remoteVideo');
const sigState = document.getElementById('sigState');
const iceState = document.getElementById('iceState');
const connState = document.getElementById('connState');
const log = document.getElementById('log');
function logln(s){ log.textContent += s + "\n"; }

function getIceServers(){
  const servers = [{urls:'stun:stun.l.google.com:19302'}];
  const turn = document.getElementById('turnUrl')?.value.trim();
  const u = document.getElementById('turnUser')?.value;
  const p = document.getElementById('turnPass')?.value;
  if (turn) servers.push({ urls: turn, username: u || undefined, credential: p || undefined });
  return servers;
}
function ensurePC(){
  if (pc) return pc;
  pc = new RTCPeerConnection({ iceServers: getIceServers() });
  pc.addEventListener('signalingstatechange', ()=> sigState.textContent = 'signaling: ' + pc.signalingState);
  pc.addEventListener('iceconnectionstatechange', ()=> iceState.textContent = 'ice: ' + pc.iceConnectionState);
  pc.addEventListener('connectionstatechange', ()=> connState.textContent = 'conn: ' + pc.connectionState);
  pc.addEventListener('track', e => { if (e.streams && e.streams[0]) remoteVideo.srcObject = e.streams[0]; });
  pc.addEventListener('icecandidate', e => {
    if (e.candidate) sendSig({kind:'candidate', from:'viewer', candidate: toPlainCandidate(e.candidate)});
    else sendSig({kind:'end-of-candidates', from:'viewer'});
  });
  pc.addEventListener('icegatheringstatechange', ()=> { if (pc.iceGatheringState==='complete') logln('gathering complete'); });
  return pc;
}

async function handleSignal(msg){
  if (!msg || msg.room !== room) return;
  if (msg.pin !== undefined && msg.pin !== pin) return; // PIN mismatch → игнор

  if (msg.kind === 'offer' && msg.sdp) {
    try {
      const pc2 = ensurePC();
      await pc2.setRemoteDescription(msg.sdp);
      const answer = await pc2.createAnswer();
      await pc2.setLocalDescription(answer);
      sendSig({ kind:'answer', sdp: pc2.localDescription });
      logln('answer sent');
      startStats();
    } catch(e){ logln('error: ' + (e.message||e)); }
    return;
  }
  if (msg.kind === 'end-of-candidates'){ try{ ensurePC().addIceCandidate(null); }catch(e){} return; }
  if (msg.kind === 'candidate' && msg.from === 'sender' && msg.candidate){
    try { await ensurePC().addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch(e){ logln('addIceCandidate error: '+(e.message||e)); }
    return;
  }
}

// Telemetry: RTT + inbound bitrate
let statsTimer=null, prevBytes=0, prevTs=0;
function humanBps(bps){
  if (bps<1e3) return bps.toFixed(0)+' bps';
  if (bps<1e6) return (bps/1e3).toFixed(1)+' kbps';
  if (bps<1e9) return (bps/1e6).toFixed(1)+' Mbps';
  return (bps/1e9).toFixed(1)+' Gbps';
}
function startStats(){
  stopStats();
  prevBytes=0; prevTs=0;
  statsTimer = setInterval(async ()=>{
    if (!pc) return;
    try {
      const stats = await pc.getStats();
      let bytes=0, rtt=null, now=performance.now();
      stats.forEach(r=>{
        if (r.type==='inbound-rtp' && r.kind==='video') bytes += r.bytesReceived||0;
        if (r.type==='candidate-pair' && r.state==='succeeded' && r.selected) rtt = r.currentRoundTripTime ?? rtt;
        if (!rtt && r.type==='transport') rtt = r.roundTripTime ?? rtt;
      });
      if (prevTs && bytes>=prevBytes){
        const bps = (bytes-prevBytes)*8*1000/(now-prevTs);
        brBadge.textContent = 'Bitrate: ' + humanBps(bps);
      }
      if (typeof rtt==='number') rttBadge.textContent = 'RTT: ' + (rtt*1000).toFixed(0) + ' ms';
      prevBytes=bytes; prevTs=now;
    } catch {}
  }, 1000);
}
function stopStats(){ if (statsTimer){ clearInterval(statsTimer); statsTimer=null; brBadge.textContent='Bitrate: —'; rttBadge.textContent='RTT: —'; } }

// Local overlay clock
(function(){
  const el = document.getElementById('clockOverlay');
  function fmt(n){ return (n<10?'0':'')+n; }
  function tick(){
    const d = new Date();
    const s = `${fmt(d.getHours())}:${fmt(d.getMinutes())}:${fmt(d.getSeconds())}`;
    if (el) el.textContent = s;
    requestAnimationFrame(tick);
  }
  tick();
})();

// Iframe hint
(function(){
  const iframe = document.getElementById('clockZoneFrame');
  if (!iframe) return;
  iframe.addEventListener('load', ()=>{ iframe.title = 'Embedded from clock.zone; if blank, site may block embedding. Overlay clock above always works.'; });
})();

// Autoconnect on load
window.addEventListener('DOMContentLoaded', connectWS);
</script>
</body>
</html>
