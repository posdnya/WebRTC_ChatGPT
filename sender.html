<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Sender</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-right:6px;background:#888}
    .dot.live{background:#e33}
    .timer{margin-left:8px;opacity:.8}
    select{padding:8px 10px;border:1px solid #8883;border-radius:10px}
  </style>
</head>
<body>
  <header><b>WebRTC Sender</b> <span class="small">— share a window in one click</span></header>
  <main>
    <div class="card">
      <div class="row">
        <label class="small">WS URL
          <input id="wsUrl" type="text" value="wss://ws.elecard-signal.com" />
        </label>
        <label class="small">Room
          <input id="room" type="text" value="posdnya" style="width:120px" />
        </label>
        <label class="small">PIN
          <input id="pin" type="text" value="1234" style="width:100px" />
        </label>
        <button id="btnConnect">Connect</button>
        <button id="btnDisconnect" disabled>Disconnect</button>
        <span id="wsStatus" class="small badge">WS: Disconnected</span>
        <button id="btnCopyLink" class="small">Copy viewer link</button>
      </div>
      <details class="small" style="margin-top:8px;"><summary>TURN (optional)</summary>
        <div class="row">
          <label>turn URL <input id="turnUrl" type="text" placeholder="turn:host:3478 or turns:host:5349"></label>
          <label>user <input id="turnUser" type="text" placeholder="username"></label>
          <label>pass <input id="turnPass" type="text" placeholder="credential"></label>
          <span class="small">Leave empty to prefer DIRECT path.</span>
        </div>
      </details>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnShare">Share a window…</button>
        <button id="btnStop" disabled>Stop</button>
        <label class="small"><input id="withAudio" type="checkbox"> include system audio</label>

        <label class="small">Quality
          <select id="quality">
            <option value="1280x720@30|2500000">720p@30 • 2.5 Mbps</option>
            <option value="1920x1080@30|4000000" selected>1080p@30 • 4 Mbps</option>
            <option value="1920x1080@60|6000000">1080p@60 • 6 Mbps</option>
            <option value="2560x1440@30|8000000">1440p@30 • 8 Mbps</option>
            <option value="3840x2160@30|15000000">4K@30 • 15 Mbps</option>
          </select>
          <button id="applyQual" class="small">Apply</button>
        </label>

        <span id="shareBadge" class="small badge idle" title="Screen share status">
          <span id="liveDot" class="dot"></span>LIVE <span id="liveTimer" class="timer">00:00</span>
        </span>
        <span id="shareInfo" class="small"></span>
      </div>
      <video id="localVideo" playsinline muted></video>
      <div class="sep"></div>
      <div class="row small">
        <span id="sigState"></span>
        <span id="iceState"></span>
        <span id="connState"></span>
        <span id="pathState" class="badge"></span>
      </div>
      <pre id="log" class="small"></pre>
    </div>
  </main>

<script>
'use strict';
// --- URL params -> defaults
const urlParams = new URLSearchParams(location.search);
const wsUrlEl = document.getElementById('wsUrl');
const roomEl = document.getElementById('room');
const pinEl  = document.getElementById('pin');
wsUrlEl.value = urlParams.get('ws')   || wsUrlEl.value;
roomEl.value  = urlParams.get('room') || roomEl.value;
pinEl.value   = urlParams.get('pin')  || pinEl.value;

const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const wsStatus = document.getElementById('wsStatus');
const btnCopyLink = document.getElementById('btnCopyLink');
let ws = null;
let room = roomEl.value.trim();
let pin  = pinEl.value.trim();

function setWSStatus() {
  const ok = ws && ws.readyState === WebSocket.OPEN;
  wsStatus.textContent = 'WS: ' + (ok ? 'Connected' : 'Disconnected');
  btnConnect.disabled = ok;
  btnDisconnect.disabled = !ok;
}
roomEl.addEventListener('input', ()=> room = roomEl.value.trim());
pinEl.addEventListener('input',  ()=> pin  = pinEl.value.trim());

btnCopyLink.addEventListener('click', async ()=>{
  const u = new URL(location.href);
  u.pathname = u.pathname.replace(/sender\.html$/,'viewer.html');
  u.searchParams.set('room', room);
  if (pin) u.searchParams.set('pin', pin);
  await navigator.clipboard.writeText(u.toString());
  wsStatus.textContent = 'WS: link copied';
});

function connectWS(){
  room = roomEl.value.trim();
  pin  = pinEl.value.trim();
  const url = wsUrlEl.value.trim();
  if (!url || !room) { alert('Fill WS URL and Room'); return; }
  if (ws) try { ws.close(); } catch {}
  ws = new WebSocket(url);
  ws.addEventListener('open', () => { setWSStatus(); try{ ws.send(JSON.stringify({type:'join', room, pin})); }catch(e){} });
  ws.addEventListener('close', setWSStatus);
  ws.addEventListener('error', setWSStatus);
  ws.addEventListener('message', ev => { try { handleSignal(JSON.parse(ev.data)); } catch {} });
  setWSStatus();
}
btnConnect.addEventListener('click', connectWS);
btnDisconnect.addEventListener('click', ()=>{ try { ws.close(); } catch {}; setWSStatus(); });

function toPlainCandidate(c){ return { candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex, usernameFragment: c.usernameFragment }; }
function sendSig(obj){
  if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({...obj, room, pin}));
}

let pc = null;
const localVideo = document.getElementById('localVideo');
const shareInfo = document.getElementById('shareInfo');
const withAudio = document.getElementById('withAudio');
const btnShare = document.getElementById('btnShare');
const btnStop = document.getElementById('btnStop');
const shareBadge = document.getElementById('shareBadge');
const liveDot = document.getElementById('liveDot');
const liveTimerEl = document.getElementById('liveTimer');
const qualitySel = document.getElementById('quality');
const applyQual = document.getElementById('applyQual');

const sigState = document.getElementById('sigState');
const iceState = document.getElementById('iceState');
const connState = document.getElementById('connState');
const pathState = document.getElementById('pathState');
const log = document.getElementById('log');

function logln(s){ log.textContent += s + "\n"; }
function setShareBadge(on){
  shareBadge.classList.toggle('live', !!on);
  shareBadge.classList.toggle('idle', !on);
  liveDot.classList.toggle('live', !!on);
}

function getIceServers(){
  const servers = [{urls:'stun:stun.l.google.com:19302'}];
  const turn = document.getElementById('turnUrl')?.value.trim();
  const u = document.getElementById('turnUser')?.value;
  const p = document.getElementById('turnPass')?.value;
  if (turn) servers.push({ urls: turn, username: u || undefined, credential: p || undefined });
  return servers;
}
function ensurePC(){
  if (pc) return pc;
  pc = new RTCPeerConnection({ iceServers: getIceServers() });
  pc.addEventListener('signalingstatechange', ()=> sigState.textContent = 'signaling: ' + pc.signalingState);
  pc.addEventListener('iceconnectionstatechange', ()=> {
    iceState.textContent = 'ice: ' + pc.iceConnectionState;
    updateLive();
  });
  pc.addEventListener('connectionstatechange', ()=> {
    connState.textContent = 'conn: ' + pc.connectionState;
    updateLive();
  });
  pc.addEventListener('icecandidate', e => {
    if (e.candidate) sendSig({kind:'candidate', from:'sender', candidate: toPlainCandidate(e.candidate)});
    else sendSig({kind:'end-of-candidates', from:'sender'});
  });
  pc.addEventListener('icegatheringstatechange', ()=> { if (pc.iceGatheringState==='complete') logln('gathering complete'); });
  return pc;
}

async function updatePath(){
  try {
    const stats = await ensurePC().getStats();
    let pair, local, remote;
    stats.forEach(r=>{ if (r.type==='candidate-pair' && r.selected) pair=r; if (r.type==='transport' && r.selectedCandidatePairId) pair = stats.get(r.selectedCandidatePairId) || pair; });
    if (pair){ local = stats.get(pair.localCandidateId); remote = stats.get(pair.remoteCandidateId); }
    if (local && remote) pathState.textContent = `path: ${local.candidateType}→${remote.candidateType}${pair.state==='succeeded'?' ✓':''}`;
  } catch {}
}
setInterval(updatePath, 2000);

let currentStream = null;
let videoSender = null;
let liveTimer = null;
let liveStart = 0;

function updateLive(){
  const on = currentStream && pc && pc.connectionState === 'connected';
  setShareBadge(on);
  if (on){
    if (!liveTimer){
      liveStart = Date.now();
      liveTimer = setInterval(()=>{
        const s = Math.floor((Date.now()-liveStart)/1000);
        const mm = String(Math.floor(s/60)).padStart(2,'0');
        const ss = String(s%60).padStart(2,'0');
        liveTimerEl.textContent = `${mm}:${ss}`;
      },1000);
    }
  } else {
    clearInterval(liveTimer); liveTimer=null;
    liveTimerEl.textContent = '00:00';
  }
}

async function startShare() {
  try {
    if (!isSecureContext) { alert('Use https or http://localhost'); return; }
    const constraints = { video: { displaySurface:'window' }, audio: withAudio.checked ? { systemAudio:'include' } : false };
    const stream = await navigator.mediaDevices.getDisplayMedia(constraints).catch(async e => {
      return await navigator.mediaDevices.getDisplayMedia({ video:true, audio: withAudio.checked });
    });
    localVideo.srcObject = stream;
    currentStream = stream;
    setShareBadge(true);
    btnStop.disabled = false;
    stream.getVideoTracks().forEach(t=> t.addEventListener('ended', ()=>{ try{ btnStop.click(); }catch(e){} }));

    const pc2 = ensurePC();
    videoSender = null;
    for (const t of stream.getTracks()){
      const s = pc2.addTrack(t, stream);
      if (t.kind==='video') videoSender = s;
    }

    // apply initial preset fps/bitrate
    await applyQuality();

    shareInfo.textContent = 'Capture started ✓ — creating offer…';
    const offer = await pc2.createOffer({ offerToReceiveVideo:true, offerToReceiveAudio:true });
    await pc2.setLocalDescription(offer);
    sendSig({ kind:'offer', sdp: pc2.localDescription });
    logln('offer sent');
  } catch (e) {
    shareInfo.textContent = 'Capture failed: ' + (e.message || e);
  }
}
btnShare.addEventListener('click', startShare);
btnStop.addEventListener('click', ()=>{
  try{
    if (currentStream){ currentStream.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} }); currentStream=null; }
    localVideo.srcObject = null;
    setShareBadge(false);
    btnStop.disabled = true;
    shareInfo.textContent = 'Sharing stopped';
    updateLive();
  }catch(e){}
});

async function applyQuality(){
  if (!currentStream || !videoSender) return;
  const [whf, br] = qualitySel.value.split('|');
  const [, fps] = whf.split('@');
  const maxBitrate = Number(br);
  try{
    const track = currentStream.getVideoTracks()[0];
    await track.applyConstraints({ frameRate: Number(fps) });
    const p = videoSender.getParameters();
    if (!p.encodings) p.encodings = [{}];
    p.encodings[0].maxBitrate = maxBitrate; // bps
    await videoSender.setParameters(p);
    track.contentHint = 'motion';
    shareInfo.textContent = `Preset applied: ${whf}, ${Math.round(maxBitrate/1000)} kbps`;
  }catch(e){ shareInfo.textContent = 'Quality apply failed: ' + e.message; }
}
applyQual.addEventListener('click', applyQuality);

async function handleSignal(msg){
  if (!msg || msg.room !== room) return;
  if (msg.pin !== undefined && msg.pin !== pin) return; // PIN mismatch → игнор

  if (msg.kind === 'answer' && msg.sdp) {
    try { await ensurePC().setRemoteDescription(msg.sdp); logln('answer set ✓'); updateLive(); } catch(e){ logln('setRemoteDescription error: '+e.message); }
    return;
  }
  if (msg.kind === 'end-of-candidates'){ try{ ensurePC().addIceCandidate(null); }catch(e){} return; }
  if (msg.kind === 'candidate' && msg.from === 'viewer' && msg.candidate){
    try { await ensurePC().addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch(e){ logln('addIceCandidate error: '+(e.message||e)); }
    return;
  }
}

// Autoconnect on load
window.addEventListener('DOMContentLoaded', connectWS);
</script>
</body>
</html>
